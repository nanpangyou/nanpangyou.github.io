<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>男胖友de部落格</title>
    <link>https://nanpangyou.github.io/docs/</link>
    <description>Recent content on 男胖友de部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Oct 2021 16:56:47 +0000</lastBuildDate><atom:link href="https://nanpangyou.github.io/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>https://nanpangyou.github.io/docs/about/</link>
      <pubDate>Tue, 21 Dec 2021 14:42:34 +0800</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/about/</guid>
      <description>关于我 </description>
    </item>
    
    <item>
      <title>tmux</title>
      <link>https://nanpangyou.github.io/docs/post/tmux/</link>
      <pubDate>Wed, 27 Oct 2021 16:56:47 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/tmux/</guid>
      <description>&lt;h1 id=&#34;tumx-使用备忘&#34;&gt;Tumx 使用备忘&lt;/h1&gt;
&lt;h2 id=&#34;什么是tmux&#34;&gt;什么是tmux&lt;/h2&gt;
&lt;p&gt;Tmux 是一个终端复用器（terminal multiplexer）&lt;/p&gt;
&lt;p&gt;Tmux 中有三个比较重要的概念
session, window , pane 在这里我们就把他们分别叫做会话，窗口，窗格&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>vim备忘</title>
      <link>https://nanpangyou.github.io/docs/post/vim%E5%A4%87%E5%BF%98/</link>
      <pubDate>Tue, 28 Sep 2021 23:11:07 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/vim%E5%A4%87%E5%BF%98/</guid>
      <description>Vim操作方式备忘  Command模式
分屏
:vs (vertical split), :sp(split)
全局替换
:% s/带替换内容/替换为/g
 Visual模式
使用 v 进入
使用 V 选择行
使用 ctrl+v 方块选择
 编辑模式
ctrl+h 删除上一个字符
ctrl+w 删除上一个单词
ctrl+u 删除当前行
(在终端下 ctrl+a 移动到行首 ctrl+e 移动到行尾 ctrl+b 向前移动 ctrl+f 向后移动)
 快速切换从insert模式去normal模式
除了esc还可以ctrl+c(有可能中断其他插件)还可以ctrl+[
快速切换从noraml模式去insert模式
使用 gi 快速跳转到你最后一次编辑的地方并进入插入模式
 行间搜索移动  使用f{char}可以移动到 char 字符上，t{char}移动到 char 的前一个字符 如果第一次没有搜到，可以用分号(;)/逗号(,)继续搜该行的上一个/下一个 使用F表示反过来搜索前面的字符  vim的水平移动  0 移动到行首第一个字符，^ 移动到第一个非空白字符 $ 移动到行尾，g_ 移动到行尾非空白字符  vim的页面移动  gg/G 移动到文件开头或者结尾， 使用 ctrl+o 快速返回 使用 H/M/L 跳转到屏幕的 开头（Head） 中间（Middle） 结尾（Lower） Ctrl+u ctrl+f 上下翻页 （upword/forward） zz把屏幕置为中间  vim的快速修改  常用有三个，r(replace), c(change), s(substitute) 在normal模式中 r 可以替换一个字符， s 替换并插入一个字符 使用c配合文本对象，我们可以快速进行修改  vim的查询  使用/或者?</description>
    </item>
    
    <item>
      <title>AsyncComponent</title>
      <link>https://nanpangyou.github.io/docs/post/asynccomponent/</link>
      <pubDate>Wed, 07 Jul 2021 15:41:54 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/asynccomponent/</guid>
      <description>Vue中的异步组件 当我们使用Vue时，文件会被默认打包成一个chunk文件，也就是说当我们页面初次加载的时候，浏览器会下载全量的js文件。有时文件会比较大，所以有一种优化方式是使用异步组件，使得当用户使用某一组件时才会去下载。
 Demo：
  当点击按钮时，浏览器会去下载list组件的代码，在过程中会显示loading组件，下载的包的名字是在注释中 webpackChunkName 规定的
 详情可以参考官方文档： 异步组件文档</description>
    </item>
    
    <item>
      <title>覆盖antdv的默认样式</title>
      <link>https://nanpangyou.github.io/docs/post/%E8%A6%86%E7%9B%96antdv%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Sun, 06 Dec 2020 23:49:23 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E8%A6%86%E7%9B%96antdv%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F/</guid>
      <description>在使用ant-design-vue时。
当默认样式不满足需求的时候，需要覆盖默认的样式，又不希望影响全局
 在vue.config.js中配置  module.exports = { css: { loaderOptions: { // 向 CSS 相关的 loader 传递选项 less: { lessOptions: { javascriptEnabled: true } } } } } 在组件中。如果是less。则只需要在需要的选择器下添加对应的样式 如：  .filter-option { /deep/ .ant-radio-button-wrapper { z-index: 1; color: #4a50d9; } /deep/.ant-radio-button-wrapper-checked:not(.ant-radio-button-wrapper-disabled) { background: #4a50d9; color: rgba(255, 255, 255, 0.8); } /deep/.ant-radio-button-wrapper:not(:first-child)::before { background: transparent; } </description>
    </item>
    
    <item>
      <title>eventloop</title>
      <link>https://nanpangyou.github.io/docs/post/eventloop/</link>
      <pubDate>Fri, 13 Nov 2020 02:22:19 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/eventloop/</guid>
      <description>Eventloop 关于Eventloop，大概可以理解为一种操作系统的运行机制。JS使用的就是这种运行机制来解决单线程运行带来的一些问题。
Wiki的定义如下
 &amp;ldquo;Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）&amp;rdquo;
 有关Eventloop的详细信息，可以参考Node的官方文档。
这里主要是就常见的题目来进行总结。
 Eventloop主要有6个阶段
 timers I/O callbacks idle prepare poll check close callbacks  牢记以下的三个不同阶段
 timers阶段 poll阶段 check阶段  与之对应的有三个常见的API
 setTimeout setImmediate nextTick  其中 setTimeout 会在timers阶段执行 setImmediate 会在check阶段执行 nextTick 会在每个阶段结束后立刻执行
举个🌰
setImmediate(()=&amp;gt;{ console.log(&#39;setImmediate1&#39;) setTimeout(()=&amp;gt;{ console.log(&#39;setTimeout1&#39;) },0) }) setTimeout(()=&amp;gt;{ console.log(&#39;setTimeout2&#39;) setImmediate(()=&amp;gt;{ console.log(&#39;setImmediate2&#39;) }) },0) 在这个🌰中 最外层有两个函数，分别为setImmediate和setTimeout。每个函数内部又有一个与之不同的函数
  先执行最外层</description>
    </item>
    
    <item>
      <title>动态创建vue实例</title>
      <link>https://nanpangyou.github.io/docs/post/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAvue%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Mon, 21 Sep 2020 15:08:57 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAvue%E5%AE%9E%E4%BE%8B/</guid>
      <description>动态创建一个vue实例 在写toast组件时，需要在toastPlugin中使用toast.vue文件动态创建一个vue实例，将toast组件以及相关的样式加载进来（当然也可以使用document.createElement来做，但是原生dom无法使用vue组件的生命周期）
此时则需要在pulgin中动态创建一个vue实例
步骤：
 引入toast.vue文件 使用Vue.extend创建构造函数 new一个vue实例 设置相关的属性（比如slot，事件监听等） mount到内存中 append到页面中  代码示例
import Toast from &amp;quot;./toast&amp;quot;; export default { install(Vue, options) { Vue.prototype.$toast = function(message,props) { let ToastConstructor = Vue.extend(Toast); let toast = new ToastConstructor({ propsData: {...props} }); toast.$slots.default = [message]; toast.$mount(); document.body.appendChild(toast.$el); }; } }; </description>
    </item>
    
    <item>
      <title>踩坑记录</title>
      <link>https://nanpangyou.github.io/docs/post/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 12 May 2020 11:06:31 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <description>记录一些踩坑的记录，方便事后回味  vue中自定义事件的命名和组件或者props的命名区别  事件的命名 &amp;mdash; 完全匹配监听这个事件所用的名称 组件或者props命名 &amp;mdash; vue会帮你自动转换camelCase和kebab-case（vue 推荐使用kebab-case来命名事件名）    </description>
    </item>
    
    <item>
      <title>react生命周期</title>
      <link>https://nanpangyou.github.io/docs/post/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Tue, 31 Mar 2020 10:06:14 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>React 的生命周期 React 组件生命周期的执行次数是什么样子的？   只执行一次 : constructor、 componentWillMount、componentDidMount
  执行多次 : render、 子组件的componentWillReceiveProp、componentWillUpdate、componentDidUpdate
  有条件执行 : componentWillUnmount (页面离开，组件销毁时)
  不执行的 : 根组件（ReactDOM.render在DOM上的组件）的componentWillReceiveProps（因为压根没有父组件给传递props）
  执行顺序 假设组件嵌套关系是 App里有parent组件，parent组件有child组件。
如果不涉及setState更新
 App： constructor --&amp;gt; componentWillMount --&amp;gt; render --&amp;gt; parent: constructor --&amp;gt; componentWillMount --&amp;gt; render --&amp;gt; child: constructor --&amp;gt; componentWillMount --&amp;gt; render --&amp;gt; componentDidMount (child) --&amp;gt; componentDidMount (parent) --&amp;gt; componentDidMount (App) 这时候触发App的setState事件
 App： componentWillUpdate --&amp;gt; render --&amp;gt; parent: componentWillReceiveProps --&amp;gt; componentWillUpdate --&amp;gt; render --&amp;gt; child: componentWillReceiveProps --&amp;gt; componentWillUpdate --&amp;gt; render --&amp;gt; componentDidUpdate (child) --&amp;gt; componentDidUpdate (parent) --&amp;gt; componentDidUpdate (App) 如果触发Parent的setState事件</description>
    </item>
    
    <item>
      <title>style,getComputedStyle,getBoundingClientRect的区别</title>
      <link>https://nanpangyou.github.io/docs/post/style-getcomputedstyle-getboundingclientrect%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 17 Jan 2020 15:34:21 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/style-getcomputedstyle-getboundingclientrect%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>今天在做 toast 组件的时候，发现了一个问题 大致过程如下 在做 toast 组件的时候，想支持用户自己传递 CloseButton,在 CloseButton 和 toast 主体之间做一个竖线进行分隔
由于父元素的高度本身设置的为min-height； 子元素设置height:100%;就完全无效
所以只能在mounted生命周期内用 js 进行赋值
设置了 refs =&amp;gt; 通过 vm.$refs.line.style.height 取值 发现取不到 只能通过 vm.$refs.toast.getBoundingClientRect().height 才可以取到高度
然后使用 vm.\$nextTick()api 来设置高度。
第一种方法取不到的原因是，style 只能取到行内样式，也就是说，如果你不是在标签内写 style 样式，都不能通过 style 来取到
查询 api 后使用getBoundingClientRectapi 取到了高度
参考资料： js 中 style,currentStyle,getComputedStyle 和 getBoundingClientRect 的区别以及获取 css 操作方法 JavaScript 中 getBoundingClientRect()方法详解</description>
    </item>
    
    <item>
      <title>flex-grow,flex-shrink和flex-basis</title>
      <link>https://nanpangyou.github.io/docs/post/flex-grow-flex-shrink%E5%92%8Cflex-basis/</link>
      <pubDate>Mon, 06 Jan 2020 11:24:37 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/flex-grow-flex-shrink%E5%92%8Cflex-basis/</guid>
      <description>flex 有三个属性值，分别是 flex-grow， flex-shrink， flex-basis，默认值是 0 1 auto
flex-basis 和 width 一样，他的默认值为 auto，如果和 width 属性同时设置一个值，flex-basis 会比较优先。当然工作中最好用 flex-basis，更符合规范。
flex-grow 该属性来设置，当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间。 flex-grow 的默认值为 0，意思是该元素不索取父元素的剩余空间，如果值大于 0，表示索取。值越大，索取的越厉害。
例如: 父元素宽 400px，有两子元素：A 和 B。A 宽为 100px，B 宽为 200px。
则空余空间为 400-（100+200）= 100px。
如果 A，B 都不索取剩余空间，则有 100px 的空余空间。
如果 A 索取剩余空间:设置 flex-grow 为 1，B 不索取。则最终 A 的大小为 自身宽度（100px）+ 剩余空间的宽度（100px）= 200px
如果 A，B 都设索取剩余空间，A 设置 flex-grow 为 1，B 设置 flex-grow 为 2。 则最终 A 的大小为 自身宽度（100px）+ A 获得的剩余空间的宽度（100px * (1/(1+2))） 最终 B 的大小为 自身宽度（200px）+ B 获得的剩余空间的宽度（100px * (2/(1+2))）</description>
    </item>
    
    <item>
      <title>使用npm-link或yarn-link</title>
      <link>https://nanpangyou.github.io/docs/post/%E4%BD%BF%E7%94%A8npm-link%E6%88%96yarn-link/</link>
      <pubDate>Fri, 06 Dec 2019 12:27:09 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E4%BD%BF%E7%94%A8npm-link%E6%88%96yarn-link/</guid>
      <description>使用 npm link / yarn link 开发 npm 包的时候，如果想测试用户在使用自己的代码时会出现的问题，就需要先将代码通过npm publish发布到 npm 中，然后进行 npm install 或者 yarn add 来安装
一旦代码有问题，则需要重新指定版本号，重新发布，重新下载才能进行调试
遇到这种问题可以尝试在本地使用npm link或者yarn link来进行解决
用法大致如下： 当本地开发完代码后，可以在代码的目录里使用npm link或yarn link，然后去安装该包的目录里也相应使用npm link &amp;lt;packageName&amp;gt;或者yarn link &amp;lt;packageName&amp;gt;，这样安装目录里的包就会映射到本地的开发代码，而不是 npm 仓库下载的目录。
这样就可以你开发后直接看到用户使用你的包的效果了
如果想取消这种映射关系，需要使用npm unlink &amp;lt;packageName&amp;gt;或者yarn unlink &amp;lt;packageName&amp;gt;在两个目录里都执行一次。再重新安装一遍所依赖的包就可以了。</description>
    </item>
    
    <item>
      <title>使用karma-mocha-sinon和travis尝试做持续测试</title>
      <link>https://nanpangyou.github.io/docs/post/%E4%BD%BF%E7%94%A8karma-mocha-sinon%E5%92%8Ctravis%E5%B0%9D%E8%AF%95%E5%81%9A%E6%8C%81%E7%BB%AD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Wed, 04 Dec 2019 20:31:52 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E4%BD%BF%E7%94%A8karma-mocha-sinon%E5%92%8Ctravis%E5%B0%9D%E8%AF%95%E5%81%9A%E6%8C%81%E7%BB%AD%E6%B5%8B%E8%AF%95/</guid>
      <description>Karma（[ˈkɑrmə] 卡玛）是一个测试运行器，它可以呼起浏览器，加载测试脚本，然后运行测试用例 Mocha（[ˈmoʊkə] 摩卡）是一个单元测试框架/库，它可以用来写测试用例 Sinon（西农）是一个 spy / stub / mock 库，用以辅助测试 travis 是一个免费的 CI 平台  安装各种工具 npm i -D karma karma-chrome-launcher karma-mocha karma-sinon-chai mocha sinon sinon-chai karma-chai karma-chai-spies 在根目录里创建karma.config.js karma.config.js中主要制定了测试的浏览器。带测试的文件（file 项下的配置）
// 新建 karma.conf.js，内容如下 module.exports = function(config) { config.set({ // base path that will be used to resolve all patterns (eg. files, exclude) basePath: &amp;quot;&amp;quot;, // frameworks to use // available frameworks: https://npmjs.org/browse/keyword/karma-adapter frameworks: [&amp;quot;mocha&amp;quot;, &amp;quot;sinon-chai&amp;quot;], client: { chai: { includeStack: true } }, // list of files / patterns to load in the browser // **/*.</description>
    </item>
    
    <item>
      <title>css属性</title>
      <link>https://nanpangyou.github.io/docs/post/css%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Wed, 13 Nov 2019 18:12:29 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/css%E5%B1%9E%E6%80%A7/</guid>
      <description>遇见的，不会的，CSS 属性   backface-visibility
功能： 隐藏被旋转的 div 元素的背面
&amp;lt;style&amp;gt; div { position:relative; height:60px; width:60px; border:1px solid #000; background-color:yellow; transform:rotateY(180deg); -webkit-transform:rotateY(180deg); /* Chrome and Safari */ -moz-transform:rotateY(180deg); /* Firefox */ } #div1 { -webkit-backface-visibility:hidden; -moz-backface-visibility:hidden; -ms-backface-visibility:hidden; } #div2 { -webkit-backface-visibility:visible; -moz-backface-visibility:visible; -ms-backface-visibility:visible; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;本例有两个 div 元素，均旋转 180 度，背向用户。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;第一个 div 元素的 backface-visibility 属性设置为 &amp;quot;hidden&amp;quot;，所以应该是不可见的。&amp;lt;/p&amp;gt; &amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;DIV 1&amp;lt;/div&amp;gt; &amp;lt;div id=&amp;quot;div2&amp;quot;&amp;gt;DIV 2&amp;lt;/div&amp;gt; can i use
  user-select
功能：可以使元素中的文字不被选中,在日常需求中,以一些需求会要求比如链接等地方的文字不可被选中，这个时候就可以使用这个属性</description>
    </item>
    
    <item>
      <title>CSS-Variable</title>
      <link>https://nanpangyou.github.io/docs/post/css-variable/</link>
      <pubDate>Tue, 05 Nov 2019 10:38:24 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/css-variable/</guid>
      <description>CSS变量 语法： 定义变量： --variableName 调用变量： var(--variableName) 默认值： var(--variableName, defaultValue) 1. 当 &amp;ndash;variableName 不存在的时候，将会使用默认值 2. 当浏览器不支持时，也应该使用默认值 3. 变量名区分大小写
.className{ --fontcolor: red; } .className2{ color: var(--fontcolor) } .className3{ color: var(--fontcolor, yellow) } 层级 你创建的变量可以在该元素本身以及该元素的子元素内使用
根元素
:root{ --fontcolor: red; } 在根元素定义的变量，则在全局都可以使用fontcolor变量
优先级 在元素内创建变量
.app{ --fontcolor: blue; } :root内定义的变量是整个页面的，如果在元素内定义同样的变量，则会覆盖全局变量（就近原则）
媒体查询 当屏幕的宽度小于等于350px的时候， &amp;ndash;fontcolor的值会被改变为green，那么应用了该变量的元素的样式则会发生响应式修改
@media (max-width: 350px){ :root{ --fontcolor: green; } } </description>
    </item>
    
    <item>
      <title>为什么在zsh中curl命令总有一个%</title>
      <link>https://nanpangyou.github.io/docs/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8zsh%E4%B8%ADcurl%E5%91%BD%E4%BB%A4%E6%80%BB%E6%9C%89%E4%B8%80%E4%B8%AA/</link>
      <pubDate>Thu, 17 Oct 2019 16:52:26 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8zsh%E4%B8%ADcurl%E5%91%BD%E4%BB%A4%E6%80%BB%E6%9C%89%E4%B8%80%E4%B8%AA/</guid>
      <description>在本地搭建了一个简单的 server 在测试的过程中 每次使用curl命令中，打印出来的返回字符串末尾都会自带一个%
原因： 由于使用的 zsh
这是一个 zsh 功能,如果该命令在其输出结尾处尚未包含换行符,则在命令完成后打印百分比和换行符. curl 可以打印从源头获得的任何结果,并且不会在没有被要求的情况下自发地打印换行.
如果正在编写使用 curl 的工具,当然可以选择自己添加换行符
$curl http://localhost:9999/1.js alert(1)% $curl -w &#39;\n&#39; http://localhost:9999/1.js alert(1) </description>
    </item>
    
    <item>
      <title>js-继承</title>
      <link>https://nanpangyou.github.io/docs/post/js-%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 23 Sep 2019 15:25:24 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/js-%E7%BB%A7%E6%89%BF/</guid>
      <description>使用 JavaScript 实现继承 要求： 要求不使用 class，完成如下需求：
  写出一个构造函数 Animal 输入为空 输出为一个新对象，该对象的共有属性为 {行动: function(){}}，没有自有属性
  再写出一个构造函数 Human Human 继承 Animal 输入为一个对象，如 {name: &amp;lsquo;xxx&amp;rsquo;, birthday: &amp;lsquo;2000-10-10&amp;rsquo;} 输出为一个新对象，该对象自有的属性有 name 和 birthday，共有的属性有物种（人类）、行动和使用工具
  再写出一个构造函数 Asian Asian 继承 Human 输入为一个对象，如 {city: &amp;lsquo;北京&amp;rsquo;, name: &amp;lsquo;xxx&amp;rsquo;, birthday: &amp;lsquo;2000-10-10&amp;rsquo; } 输出为一个新对象，改对象自有的属性有 name city 和 bitrhday，共有的属性有物种、行动和使用工具和肤色 既
  最后一个新对象是 Asian 构造出来的
 Asian 继承 Human，Human 继承 Animal 使用原型链
function Animal(){ } Animal.prototype.行动 = function(){} function Human(options){ this.</description>
    </item>
    
    <item>
      <title>奇怪的代码</title>
      <link>https://nanpangyou.github.io/docs/post/%E5%A5%87%E6%80%AA%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 11 Sep 2019 09:41:40 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E5%A5%87%E6%80%AA%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>&amp;lt;!Doctype html&amp;gt; &amp;lt;script&amp;gt; const x = &amp;quot;sfds&amp;quot;; console.log(typeof x); //String console.log(typeof window.x); //undefined &amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; console.log(typeof x); //String console.log(typeof window.x); //undefined &amp;lt;/script&amp;gt; // es6 开始，let， const， class 声明的全局变量，不属于顶层对象的属性, 上下两个的作用域都是全局
  const arr = new Array(5).fill([]) arr[0].push(&#39;hi&#39;) console.log(arr) //如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 MDN: 当一个对象被传递给 fill 方法的时候, 填充数组的是这个对象的引用。
  var number = 10; function fn() { console.log(this) console.log(this.number); } var obj = { number: 2, show: function(fn) { this.number = 3; fn(); arguments[0](); }, }; obj.</description>
    </item>
    
    <item>
      <title>js-异步</title>
      <link>https://nanpangyou.github.io/docs/post/js-%E5%BC%82%E6%AD%A5/</link>
      <pubDate>Mon, 09 Sep 2019 11:04:01 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/js-%E5%BC%82%E6%AD%A5/</guid>
      <description>同步和异步 同步： 等待结果 异步： 不等待结果
异步通常和回调一起出现，但是要注意，异步不是回调，回调也不一定是异步。
常见的异步代码  获取图片的宽高   var w = document.getElementByTagName(&#39;img&#39;)[0].width console.log(w) //0 解决办法：
使用 img 的 onload(表示图片已经下载并加载完成)事件来重新触发获取宽度的函数
 var img = document.getElementByTagName(&#39;img&#39;)[0] img.onload = function(){ var w = img.width console.log(w) } 事件绑定的异步   let liList = document.querySelectorAll(&#39;li&#39;) for ( var i = 0;i &amp;lt; liList.length; i++ ){ liList[i].on(&#39;click&#39;,function(){ console.log(i) }) } 解决办法：
将循环中变量的关键字 i 的声明关键字改为 let
 let liList = document.querySelectorAll(&#39;li&#39;) for ( let i = 0;i &amp;lt; liList.</description>
    </item>
    
    <item>
      <title>代码片段-js</title>
      <link>https://nanpangyou.github.io/docs/post/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-js/</link>
      <pubDate>Sat, 07 Sep 2019 16:23:58 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-js/</guid>
      <description>curry 函数（可以将函数柯里化的函数） 当传入的参数个数没有到达 func 函数要求的参数个数的时候一直返回柯里化函数。 只有参数满足 func 函数的个数的时候才通过 apply 执行 func 函数
 /* function curry(???){ ??? return ??? } var abc = function(a, b, c) { return [a, b, c]; }; */ function curry(fn,thisArg){ if ( !Array.isArray(thisArg) ) { thisArg = []; } return function(){ let args = Array.prototype.slice.call(arguments); if ( (args.length+thisArg.length) &amp;lt; fn.length ) { return curry(fn , thisArg.concat(args)); } return fn.apply(this , thisArg.concat(args)); }; } var abc = function(a, b, c) { return [a, b, c]; }; var curried = curry(abc); curried(1)(2)(3); curried(1, 2)(3); curried(1, 2, 3); 参考博客</description>
    </item>
    
    <item>
      <title>js-函数</title>
      <link>https://nanpangyou.github.io/docs/post/js-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 30 Aug 2019 10:33:22 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/js-%E5%87%BD%E6%95%B0/</guid>
      <description>JavaScript 函数 js 中的函数
定义  匿名函数 具名函数 箭头函数  // 匿名函数 var fn = function(){ return 1 } fn2 = fn; fn.name //fn fn2.name //fn // 具名函数 function fn3(){ return 1 } //fn3的作用域是全局 var fn5 = function fn4(){ return 5 } //如果将一个具名函数赋值给一个变量，那么这个具名函数的作用域就是该函数的花括号内 //例如fn4这个具名函数赋值给了fn5 那么fn4存在的作用域就是fn4的花括号内 // 箭头函数 var fn = () =&amp;gt; {} var fn2 = e =&amp;gt; console.log(e) var fn3 = (a, b) =&amp;gt; { let c = a + b; return c; } 词法作用域（也叫静态作用域） var global = 1; function fn1(param1){ var local1 = &#39;local1&#39; var local2 = &#39;local2&#39; function fn2(param2){ var local2 = &#39;inner local2&#39; console.</description>
    </item>
    
    <item>
      <title>Node-4</title>
      <link>https://nanpangyou.github.io/docs/post/node-4/</link>
      <pubDate>Thu, 29 Aug 2019 11:03:50 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/node-4/</guid>
      <description>Node 原生服务器搭建(简单版) // 引入http模块 let http = require(&amp;quot;http&amp;quot;); // 引入查询字符串处理函数 let { parse } = require(&amp;quot;querystring&amp;quot;); // 创建server对象 let server = http.createServer((request, response) =&amp;gt; { // request 请求对象 // response 返回对象 console.log(request.url); let str = request.url.split(&amp;quot;?&amp;quot;)[1]; let obj = parse(str); console.log(obj); response.setHeader(&amp;quot;content-type&amp;quot;, &amp;quot;text/html;charset=utf-8&amp;quot;); if (obj.haha === &amp;quot;1&amp;quot;) { response.end(&amp;quot;h1&amp;quot;); } else { response.end(&amp;quot;&amp;lt;h1&amp;gt;服务器启动成功&amp;lt;/h1&amp;gt;&amp;quot;); } }); // 监听端口 server.listen(9999, err =&amp;gt; { if (!err) { console.log(&amp;quot;服务器启动成功&amp;quot;); } else { console.log(&amp;quot;服务器启动失败&amp;quot;); } }); </description>
    </item>
    
    <item>
      <title>Node-3</title>
      <link>https://nanpangyou.github.io/docs/post/node-3/</link>
      <pubDate>Mon, 26 Aug 2019 15:30:49 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/node-3/</guid>
      <description>mongoose 一个概念 非关系型数据库：对象文档模型（ODM）库 关系型数据库：对象关系模型（ORM）映射表
Mongoose Mongoose 是一个对象文档模型（ODM）库，它对 Node 原生的 MongoDB 模块进行了优化封装，并提供了很多功能。
优点：
 可以为文档创建一个模式结构（Schema） 可以对模型中的对象/文档进行验证 数据可以通过类型转换转换为对象模型 可以使用中间件来应用业务逻辑挂钩 比 Node 原生的 MongoDB 驱动更容易  明确几个概念
 mongoDB: 一个非关系型数据库的名称 mongod: 启动 mongo 服务的命令 mongo: 连接数据库的命令 mongoose: 在 Node 端连接数据库的一个库
 Mongoose 的 CRUD   Create
模型对象.create(文档对象,回调函数) 模型对象.create(文档对象) //返回值是一个 Promise 对象
  Read
模型对象.find(查询条件[,投影]) //不管有没有数据，都返回一个数组 模型对象.findOne(查询条件[,投影]) //找到了返回一个对象，没找到返回 NULL
    Update
模型对象.updateOne(查询条件,要更新的内容[,配置对象]) 模型对象.updateMany(查询条件,要更新的内容[,配置对象]) 备注：存在 update 方法，但是即将废弃，查询条件匹配多个时，只会更新一个，建议使用 updateOne()
  Delete</description>
    </item>
    
    <item>
      <title>Node-2</title>
      <link>https://nanpangyou.github.io/docs/post/node-2/</link>
      <pubDate>Mon, 26 Aug 2019 11:00:03 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/node-2/</guid>
      <description>Mongodb 数据库分类  关系型数据库（RDBS） 如 MySQL, Oracle, DB2, SQL server &amp;hellip;  优点 ：
 易于维护： 都是使用表结构，格式一致 使用方便： SQL 语言通用，可用于复杂查询 高级查询： 可用于多表之间的复杂查询  缺点 ：
 读写性能比较差，尤其是海量数据的高效率读写 有固定的表结构，字段不可以随意修改，灵活度欠缺 高并发的读写需求，传统关系行数据库来说， 硬盘 I/O 是一个很大的瓶颈  非关系型数据库 如 MongoDB, Redis &amp;hellip;  优点 ：
 格式灵活：存储数据的格式可以是 key value 格式 速度快：nosql 可以内存作为载体，而关系型数据库只能用硬盘 易用： nosql 部署简单  缺点 ：
 不支持 sql 不支持事务  关键字    关系型数据库 非关系型数据库     数据库 数据库   表 集合   每一条数据 文档    MongoDB 安装后的一些注意  使用 homebrew 安装 MongoDB  brew install mongodb  安装成功后可使用 mongod -version 来查看是否成功</description>
    </item>
    
    <item>
      <title>Node-1</title>
      <link>https://nanpangyou.github.io/docs/post/node-1/</link>
      <pubDate>Fri, 23 Aug 2019 15:59:19 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/node-1/</guid>
      <description>Node - 1 Buffer 缓冲器 什么是 Buffer ?
 它是一个类似于数组的对象，用于存储数据（存储的是二进制数据） Buffer 的效率很高，存储和读取的速度很快，直接对计算机的内存进行操作。 Buffer 的大小一旦确定了，就不可修改 每个元素占用内存的大小为 1 字节 Buffer 是 Node 中非常核心的模块，无需下载和引用就可以直接使用  使用示例
1. Buffer.from() // 将一个字符串存入Buffer中 let str = &#39;hello world&#39; let buf = Buffer.from(str) console.log(buf) 2. Buffer.alloc(); //alloc()方法创建Buffer的效率一般 会开辟一块完全没有使用过的空间 let buf2 = Buffer.alloc(); console.log(buf2) 3. Buffer.allocUnsafe(); //allocUnsafe()方法创建Buffer的效率很好，但是会有一些安全问题 会返回一块没有被引用的空间（有可能会有其他方法不用的数据，数据可能会有安全问题） let buf3 = Buffer.allocUnsafe() console.log(buf3) 4. new Buffer() // 官方不推荐，说是在后续会删除，效率也不高 let buf4 = new Buffer() console.log(buf4) Node 文件系统 Node 中的文件系统：</description>
    </item>
    
    <item>
      <title>Node-0</title>
      <link>https://nanpangyou.github.io/docs/post/node-0/</link>
      <pubDate>Fri, 23 Aug 2019 09:42:47 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/node-0/</guid>
      <description>Node - 0 什么是 Node？ 维基百科：
 Node.js is an open-source, cross-platform, JavaScript run-time environment that executes JavaScript code outside of a browser.
 大意是 Node.js 是一款开源的，跨平台的，能让 JavaScript 在浏览器以外运行的运行环境
优点  异步非阻塞的 I/O 适用于 I/O 密集型应用 事件循环机制 单线程 跨平台  缺点  回调函数较多，嵌套较深 单线程，处理不好 CPU 密集型任务  Node 的应用场景（大概）  Web 服务的 API 服务端渲染 后端的 web 服务，如跨域，服务器端请求  Node 中函数的特点 我们可以通过 console.log(arguments.callee.toString()) 来看到整个 Node 是通过一个大函数 function (exports, require, module, __filename, __dirname) { } 所包裹的，其中前三个是有关模块化的参数， __filename 是指但前文件的绝对路径 __dirname是指当前文件夹的绝对路径。</description>
    </item>
    
    <item>
      <title>vue组件之间传参之兄弟组件</title>
      <link>https://nanpangyou.github.io/docs/post/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%8F%82%E4%B9%8B%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 19 Aug 2019 15:01:08 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%8F%82%E4%B9%8B%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6/</guid>
      <description>vue 组件传参之兄弟组件 之前有一篇写了 vue 组件传参，主要写了父子组件之间的传参，通过 props 和 $emit(&#39;eventName&#39;) 的方式。
这次主要来写一下另一种情况，两个平级的兄弟组件之间怎么传参。
主要原理和父子组件之间通过触发事件来传参差不多 如何做：
 兄弟组件之间的传参需要借助 eventBus 这个概念。 eventBus 其实也是一个 vue 实例。 兄弟组件通过引入同一个 eventBus 来建立联系，触发并且监听同一个事件来进行传参 数据发送方，通过触发 bus.$emit(&#39;eventName&#39;, data) 来发送数据 数据接收方，通过 bus.$on(&#39;eventName&#39;, (data)=&amp;gt;console.log(data)) 其中 $on 的回调函数就可以接受传参  上 Demo：
父组件 // 父组件（主要在 Demo 中做包裹层） &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;component-a&amp;gt;&amp;lt;/component-a&amp;gt; &amp;lt;component-b&amp;gt;&amp;lt;/component-b&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; eventBus.js // eventBus.js( 事件车，主要是用来承载监听函数) import Vue from &#39;vue&#39; export default new Vue(); 组件 A // 组件A 事件的触发方 &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;a组件&amp;lt;/h1&amp;gt; &amp;lt;button @click=&amp;quot;abtn&amp;quot;&amp;gt;A按钮&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import eventVue from &amp;quot;.</description>
    </item>
    
    <item>
      <title>url编码</title>
      <link>https://nanpangyou.github.io/docs/post/url%E7%BC%96%E7%A0%81/</link>
      <pubDate>Tue, 13 Aug 2019 15:39:32 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/url%E7%BC%96%E7%A0%81/</guid>
      <description>encodeURI() 和 encodeURIComponent() 方法 encodeURI() 和 encodeURIComponent() 方法，通常都用来进行对 url 的编码。
  为什么要编码： 标准的 url 中不可以出现特殊字符，如 空格 等，如果有则会造成浏览器无法正确理解 url，因此需要使用 utf-8 来对特殊的字符进行替换
  区别： encodeURI() 方法常用来对整个 URL 进行编码，但是对本身属性 url 的特殊字符进行编码，例如“冒号、正斜杠、问号、井号”则不转换。 encodeURIComponent() 方法常用域对 url 中的某一块进行编码，一般是参数部分，他会将任何非标准字符进行编码。
  对应的解码函数： encodeURI() =&amp;gt; decodeURI() encodeURIComponent() =&amp;gt; decodeURIComponent()
  </description>
    </item>
    
    <item>
      <title>VueRouter在Webpack上的坑</title>
      <link>https://nanpangyou.github.io/docs/post/vuerouter%E5%9C%A8webpack%E4%B8%8A%E7%9A%84%E5%9D%91/</link>
      <pubDate>Fri, 02 Aug 2019 17:48:53 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/vuerouter%E5%9C%A8webpack%E4%B8%8A%E7%9A%84%E5%9D%91/</guid>
      <description>VueRouter 学习笔记之在 Webpack(4.X) 上的坑 通常 VueRouter 给我们提供了常用的两种方式的使用
  hash 模式 在 url 中有 # 号的存在，不美观，也不利于 SEO ，部署没有成本，用户向服务器发送请求时，浏览器会忽略 # 后面的值。刷新时不会重新请求。
  history 模式 url 看起来是正常的，会向服务器发送请求。所以在刷新的时候，会向服务器发送对应路径的请求。服务器没有对应的路径，就会报404
  解决办法，就是在 webpack 的配置项中，在 devServer 加上
//history模式下的url会请求到服务器端，但是服务器端并没有这一个资源文件，就会返回404，所以需要配置这一项 historyApiFallback: { rewrites: [{ from: /.*/g, to: &#39;/index.html&#39; //与output的publicPath有关(HTMLplugin生成的html默认为index.html) }] } </description>
    </item>
    
    <item>
      <title>flexbox布局</title>
      <link>https://nanpangyou.github.io/docs/post/flexbox%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 24 Jul 2019 11:23:58 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/flexbox%E5%B8%83%E5%B1%80/</guid>
      <description>Flex 布局 什么是 Flex 布局？ Flex 是 Flexible box 的缩写，顾名思义为“ 弹性布局 ”， 可以为盒模型提供比较大的灵活性。
兼容性 在 canIuse 上，flex 的兼容性如下 can i use
可以看到，出了老版的 ie 支持不够好以外，现在浏览器的支持都还可以，尤其移动端可以使用。
用法 任何一个容器都可以指定为 Flex 布局
.box{ display: flex; } 基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“容器”。它的所有子元素自动成为容器成员，成为 flex 项目（flex item），简称“项目”。
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框 的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。
项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。
容器属性 flex 容器主要有以下 6 个属性设置
 flex-direction flex-wrap flex-flow justify-content align-items align-content  详细说明  flex-direction  flex-direction 属性决定主轴的方向，他有 4 个属性值</description>
    </item>
    
    <item>
      <title>Promise对象</title>
      <link>https://nanpangyou.github.io/docs/post/promise%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 20 Jul 2019 10:32:28 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/promise%E5%AF%B9%E8%B1%A1/</guid>
      <description>Promise 是异步编程的一种解决方案。
简单讲 promise 就是一个容器，里面装有一个未来得到结果的函数（通常为异步）。 在 js 中，promise 是以对象的形式存在，提供统一的 API， 对各种一步操作可以使用统一的方法处理。
promise 主要有两个特征。
  对象的状态不受外界影响。
 Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
   一旦状态改变，就不会再变，任何时候都可以得到这个结果。
 promise 对象的状态改变，只有两种情况： 1. 从 pending 到 fulfiled 2. 从 pending 到 rejected 。只要这两种状态发生后就冻结了，不会再变
   Promise 的基本用法 function setTime(tm) { return new Promise((resolve, reject) =&amp;gt; { // setTimeout 的第三个参数是传给回调函数的第一个参数 setTimeout(resolve, tm, &amp;quot;success&amp;quot;); // setTimeout(reject, tm, &amp;quot;somethingErr&amp;quot;); }); } setTime(4000).then( data =&amp;gt; { console.log(&amp;quot;done&amp;quot; + data); }, err =&amp;gt; { console.</description>
    </item>
    
    <item>
      <title>使用npm安装时的参数</title>
      <link>https://nanpangyou.github.io/docs/post/%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 28 Jun 2019 15:02:12 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0/</guid>
      <description>日常使用npm i xxxx 和 npm i xxx -D还有npm i xxx -S傻傻分不清。
npm i xxx -D等同于npm install xxx --save-dev，它所安装的文件会将版本信息和名字写入package.json中的devDependencies对象中。
npm i xxx -S等同于npm install xxx --save,它所安装的文件会将版本信息和名字写入package.json中的dependencies对象中。
那么问题来了，devDependencies和dependencies有什么区别？
 devDependencies
 主要是开发时所依赖的包，这个目录下的不需要部署到生产
 dependencies
 项目运行所依赖的包，需要在生产也使用</description>
    </item>
    
    <item>
      <title>Vue组件间的传值</title>
      <link>https://nanpangyou.github.io/docs/post/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</link>
      <pubDate>Tue, 18 Jun 2019 19:21:50 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</guid>
      <description>Vue 组件间的传值 Vue 组件间的传值，说白了就是父子组件和兄弟组件之间的传值。 这次梳理一下父子组件之间的传值。
Vue 父子组件之间的传值 👨👦 传值主要涉及两种类型的传值
 单纯的值 函数（方法）   单纯的值
 单纯的值传递，主要是想将父组件data对象中的值传入子组件，在子组件中使用。
主要使用 props
&amp;lt;div class=&#39;app&#39;&amp;gt; &amp;lt;!-- 将需要传递的值通过 v-bind 的形式传递给子组件 --&amp;gt; &amp;lt;com1 :mymsg=&#39;msg&#39; &amp;gt;&amp;lt;/com1&amp;gt; &amp;lt;/div&amp;gt; var app = new Vue({ el: &#39;.app&#39;, data: { msg: &#39;要传入子组件的值&#39; }, components:{ com1:{ template: &#39;&amp;lt;div&amp;gt;{{ mymsg }}&amp;lt;/div&amp;gt;&#39;, &amp;lt;!-- 在组件中使用 props 接受父组件传递过来的值，并且声明，注意： 1，命名要一致，2.props是个数组 --&amp;gt; &amp;lt;!-- props中的值和data中的值都可以使用，区别不大，但是要注意，父组件传递过来的值不要重新赋值，赋值只会在子组件内部生效 --&amp;gt; props: [&#39;mymsg&#39;] } } })  函数传递
 父组件的函数传递给子组件，一般用在子组件内部更新后让父组件刷新状态。
主要使用 this.$emit()
&amp;lt;div class=&#39;app&#39;&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>homebrew节点</title>
      <link>https://nanpangyou.github.io/docs/post/homebrew%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 12 Jun 2019 14:50:48 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/homebrew%E8%8A%82%E7%82%B9/</guid>
      <description>记录可用的 homebrew 节点，解决 brew update 卡死 每次使用homebrew的时候，会首先执行brew update。由于天朝网络的原因，update 几乎没有任何相应。只能先进行ctrl+c再执行安装命令.
解决办法
更改homebrew的镜像节点
# 进入brew主目录 $ cd `brew --repo` # 更换镜像 $ git remote set-url origin https://git.coding.net/homebrew/homebrew.git # 测试效果 $ brew update 可用的节点还有
 https://git.coding.net/homebrew/homebrew.git - Coding https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git - 清华 https://mirrors.ustc.edu.cn/brew.git - 中科大  </description>
    </item>
    
    <item>
      <title>Vue——transition动画的一个小注意点</title>
      <link>https://nanpangyou.github.io/docs/post/vuetransition%E5%8A%A8%E7%94%BB%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%B3%A8%E6%84%8F%E7%82%B9/</link>
      <pubDate>Thu, 30 May 2019 15:43:14 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/vuetransition%E5%8A%A8%E7%94%BB%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%B3%A8%E6%84%8F%E7%82%B9/</guid>
      <description>太长不看就记住display属性不能transition 起源于日常进行着龟速的Vue自啃。
看到有关于transition标签相关的内容。 做了一个小小的动画实验。
Demo：
&amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;app&amp;quot;&amp;gt; &amp;lt;!-- 测试小球的动画，使用Vue自带的transition元素 --&amp;gt; &amp;lt;button @click=&amp;quot;flag = !flag&amp;quot;&amp;gt;车来了&amp;lt;/button&amp;gt; &amp;lt;transition @before-enter=&amp;quot;beforeEnter&amp;quot; @enter=&amp;quot;enter&amp;quot; @after-enter=&amp;quot;afterEnter&amp;quot; &amp;gt; &amp;lt;div class=&amp;quot;car&amp;quot; v-show=&amp;quot;flag&amp;quot;&amp;gt;车速很快&amp;lt;/div&amp;gt; &amp;lt;/transition&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var app = new Vue({ el: &amp;quot;.app&amp;quot;, data: { flag: false }, methods: { beforeEnter(el) { el.style.transform = &amp;quot;translate(0,0)&amp;quot;; }, enter(el) { el.style.transform = &amp;quot;translate(350px,0)&amp;quot;; el.style.transition = &amp;quot;all 400ms ease&amp;quot;; }, afterEnter(el) { this.flag = !this.flag; } } }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 这个demo中在transition中使用了自带的钩子函数，分别处理动画开始前（before-enter）,动画开始后到动画结束（enter），以及动画结束后（after-enter）三个不通状态的样式
在上面的代码里，虽然在enter的方法中使用了 el.style.transition = &#39;all 400ms ease&#39;,但是，代表🚗的方块并没有从开始位置逐渐过度到结束的位置。只是在结束的位置瞬间出现。</description>
    </item>
    
    <item>
      <title>拼音</title>
      <link>https://nanpangyou.github.io/docs/post/%E6%8B%BC%E9%9F%B3/</link>
      <pubDate>Mon, 27 May 2019 12:24:37 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E6%8B%BC%E9%9F%B3/</guid>
      <description>拼音到底应该怎么打 昨晚在刷知乎的时候看到一个有意思的东西，说不定以后可能会用到。
关于拼英怎么显示的问题。
之前有自己想过，如果让我自己去实现拼音的显示，大致的思路可能就是调整文本的行高。对每个文字增加伪元素或者写额外的拼音元素用定位来进行展示。
昨天看到了另外一种展示的方法。
使用&amp;lt;ruby&amp;gt;元素来进行展示。
Demo:
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ruby&amp;gt;我&amp;lt;rt&amp;gt;wo&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt; &amp;lt;ruby&amp;gt;不&amp;lt;rt&amp;gt;bu&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt; &amp;lt;ruby&amp;gt;开&amp;lt;rt&amp;gt;kai&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt; &amp;lt;ruby&amp;gt;心&amp;lt;rt&amp;gt;xin&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 一些属性： 根据 MDN 上面所写，&amp;lt;ruby&amp;gt;元素是专门用来展示东亚文字注音或字符注释。（脑补： 拼音？片甲？🤦‍♂️）
尝试后感觉应该是非块状元素。注音和文字本身都受 font 相关的 css 属性影响。
关于文字的行高，界限大致如图可以看到
兼容性比想象中的好很多 另外 配套使用的&amp;lt;rt&amp;gt;和&amp;lt;rp&amp;gt;各自有各自的用途
&amp;lt;rt&amp;gt;元素主要是用来包裹注音的内容。
&amp;lt;rp&amp;gt;元素主要是当&amp;lt;rt&amp;gt;元素不支持上标的时候。用来代替使用的。
demo：
&amp;lt;ruby&amp;gt; 漢 &amp;lt;rp&amp;gt;(&amp;lt;/rp&amp;gt;&amp;lt;rt&amp;gt;han&amp;lt;/rt&amp;gt;&amp;lt;rp&amp;gt;)&amp;lt;/rp&amp;gt; 字 &amp;lt;rp&amp;gt;(&amp;lt;/rp&amp;gt;&amp;lt;rt&amp;gt;zi&amp;lt;/rt&amp;gt;&amp;lt;rp&amp;gt;)&amp;lt;/rp&amp;gt; &amp;lt;/ruby&amp;gt; 至此～
ps： 周一日常丧（´-`）</description>
    </item>
    
    <item>
      <title>浏览器切换tab</title>
      <link>https://nanpangyou.github.io/docs/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%87%E6%8D%A2tab/</link>
      <pubDate>Wed, 15 May 2019 11:17:35 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%87%E6%8D%A2tab/</guid>
      <description>如何监听浏览器Tab页切换 最近公司系统上线比较忙，一直也没有更新，今天是上线的第5天，最近一直在跟踪bug。
今天忙里偷闲，突然想起之前公司的代码规范考试的时候，系统会监听你是否还停留在当前的tab页上
一直好奇如何实现监听浏览器的Tab页，今天大概查了一下。
主要是监听visibilitychange事件。
上Demo
document.addEventListener(&#39;visibilitychange&#39;,function(){ //浏览器切换事件 //状态判断 if(document.visibilityState==&#39;hidden&#39;) { console.log(&#39;切出事件&#39;); }else { console.log(&#39;切入事件&#39;); } }); 在Can i use上查到的兼容性。
大部分的主流较新的浏览器都可以支持。
回答了多年的疑惑，撒花🎉🎉🎉🎉🎉</description>
    </item>
    
    <item>
      <title>JS剪贴板相关</title>
      <link>https://nanpangyou.github.io/docs/post/js%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Fri, 19 Apr 2019 16:47:55 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/js%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9B%B8%E5%85%B3/</guid>
      <description>JS 剪贴板相关的内容 这两天做了一个需求，是通过 js 获取剪贴板中的字符串，对用户复制不同长度的字符串进行分类处理。
由于自己之前从来都没有关注过复制事件 paste ,于是就去网上找了找相关的资料，记录如下：
JS 是可以拿到用户所输入的内容的 paste 事件不一定需要绑定在 input 元素中，可以绑定在任意元素中，当用户鼠标在该元素上或者该元素处于 focus 状态，绑定的 paste 事件就会在复制的时候执行。
事件对象  if (window.clipboardData &amp;amp;&amp;amp; window.clipboardData.getData) { // IE pastedText = window.clipboardData.getData(&amp;quot;Text&amp;quot;); } else { //e.clipboardData.getData(&#39;text/plain&#39;); pastedText = e.originalEvent.clipboardData.getData(&amp;quot;Text&amp;quot;); } 粘贴事件为你提供了一个 clipboardData 对象, 它实际上是一个 DataTransfer 类型的对象, DataTransfer 是拖动产生的一个对象，但实际上粘贴事件也是它。
clipboardData 属性介绍
   属性 类型 说明     dropEffect String 默认是 none   effectAllowed String 默认是 uninitialized   files FileList 粘贴操作为空 List   items DataTransferItemList 剪切板中的各项数据   types Array 剪切板中的数据类型 该属性在 Safari 下比较混乱    items 介绍 items 是一个 DataTransferItemList 对象，自然里面都是 DataTransferItem 类型的数据了。</description>
    </item>
    
    <item>
      <title>ArrayAPI</title>
      <link>https://nanpangyou.github.io/docs/post/arrayapi/</link>
      <pubDate>Tue, 09 Apr 2019 15:03:23 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/arrayapi/</guid>
      <description>Array 的常见 API，有哪些会修改原数组，哪些并不会修改原数组 开发过程中，尽量不要修改后端接口返回的原始数据，当后端返回的是数组时，借用原生的数组 API 很方便操作。 但是要注意，有些 API 是会修改原数组的
会修改原数组的 API  pop() pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回 undefined，改变原数组，返回被删除的元素  var oldArray = [1,2,3,4,5,6] var delItem = oldArray.pop(); console.log(delItem); // 6 console.log(oldArray); // [1,2,3,4,5] push() push() 向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度  var oldArray = [1,2,3,4,5]; var newArrayLength = oldArray.push(7); console.log(newArrayLength); // 6 console.log(oldArray); //[1,2,3,4,5,7] reverse() reverse() 颠倒数组中元素的顺序，改变原数组，返回该数组  var oldArray = [1,2,3,4,5]; var newArray = oldArray.reverse(); console.log(newArray); // [5,4,3,2,1] console.log(oldArray); // [5,4,3,2,1] shift() shift() 把数组的第一个元素删除，若空数组，不进行任何操作，返回 undefined,改变原数组，返回第一个元素的值  var oldArray = [1,2,3,4,5] var delItem = oldArray.</description>
    </item>
    
    <item>
      <title>cssFilter</title>
      <link>https://nanpangyou.github.io/docs/post/cssfilter/</link>
      <pubDate>Wed, 03 Apr 2019 16:42:23 +0000</pubDate>
      
      <guid>https://nanpangyou.github.io/docs/post/cssfilter/</guid>
      <description>昨天在写一个需求的时候，用到半透明蒙版遮罩 之前这种需求都是用background: rgba(0,0,0,.5)或者hsla(50, 33%, 25%, 0.75)这类使用Alpha通道,或者使用opacity来增加背景层的透明度。
单单增加透明度，整体缺少质感，并且如果有文字在遮罩层上的话会使得上下文字重叠，视觉效果并不好。
毛玻璃的效果刚好可以弥补这一点。
主要用到的属性是filter: blur(10px);
代码结构不难理解
&amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt; &amp;lt;p&amp;gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Alias aperiam, sequi velit dolores accusantium voluptas. Facere dolorem tempore similique nobis eos maxime error perspiciatis temporibus, fugiat vel deserunt esse unde! &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Alias aperiam, sequi velit dolores accusantium voluptas. Facere dolorem tempore similique nobis eos maxime error perspiciatis temporibus, fugiat vel deserunt esse unde!</description>
    </item>
    
  </channel>
</rss>
