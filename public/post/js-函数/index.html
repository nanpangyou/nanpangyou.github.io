<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #f1efe1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>js-函数 - 男胖友de部落格</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="JavaScript 函数 js 中的函数
定义  匿名函数 具名函数 箭头函数  // 匿名函数 var fn = function(){ return 1 } fn2 = fn; fn.name //fn fn2.name //fn // 具名函数 function fn3(){ return 1 } //fn3的作用域是全局 var fn5 = function fn4(){ return 5 } //如果将一个具名函数赋值给一个变量，那么这个具名函数的作用域就是该函数的花括号内 //例如fn4这个具名函数赋值给了fn5 那么fn4存在的作用域就是fn4的花括号内 // 箭头函数 var fn = () =&gt; {} var fn2 = e =&gt; console.log(e) var fn3 = (a, b) =&gt; { let c = a &#43; b; return c; } 词法作用域（也叫静态作用域） var global = 1; function fn1(param1){ var local1 = &#39;local1&#39; var local2 = &#39;local2&#39; function fn2(param2){ var local2 = &#39;inner local2&#39; console." />
  <meta
    name="author"
    content="nanpangyou"
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://nanpangyou.github.io/main.min.css" />

  

  
     
  <link rel="preload" as="image" href="https://nanpangyou.github.io/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/11482364?v=4" />
  
  

  
  <link rel="preload" as="image" href="https://nanpangyou.github.io/github.svg" />
  

  
  <link rel="icon" href="https://nanpangyou.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://nanpangyou.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.93.3" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="js-函数" />
<meta property="og:description" content="JavaScript 函数 js 中的函数
定义  匿名函数 具名函数 箭头函数  // 匿名函数 var fn = function(){ return 1 } fn2 = fn; fn.name //fn fn2.name //fn // 具名函数 function fn3(){ return 1 } //fn3的作用域是全局 var fn5 = function fn4(){ return 5 } //如果将一个具名函数赋值给一个变量，那么这个具名函数的作用域就是该函数的花括号内 //例如fn4这个具名函数赋值给了fn5 那么fn4存在的作用域就是fn4的花括号内 // 箭头函数 var fn = () =&gt; {} var fn2 = e =&gt; console.log(e) var fn3 = (a, b) =&gt; { let c = a &#43; b; return c; } 词法作用域（也叫静态作用域） var global = 1; function fn1(param1){ var local1 = &#39;local1&#39; var local2 = &#39;local2&#39; function fn2(param2){ var local2 = &#39;inner local2&#39; console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nanpangyou.github.io/post/js-%E5%87%BD%E6%95%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-30T10:33:22+00:00" />
<meta property="article:modified_time" content="2019-08-30T10:33:22+00:00" />


  
  <meta itemprop="name" content="js-函数">
<meta itemprop="description" content="JavaScript 函数 js 中的函数
定义  匿名函数 具名函数 箭头函数  // 匿名函数 var fn = function(){ return 1 } fn2 = fn; fn.name //fn fn2.name //fn // 具名函数 function fn3(){ return 1 } //fn3的作用域是全局 var fn5 = function fn4(){ return 5 } //如果将一个具名函数赋值给一个变量，那么这个具名函数的作用域就是该函数的花括号内 //例如fn4这个具名函数赋值给了fn5 那么fn4存在的作用域就是fn4的花括号内 // 箭头函数 var fn = () =&gt; {} var fn2 = e =&gt; console.log(e) var fn3 = (a, b) =&gt; { let c = a &#43; b; return c; } 词法作用域（也叫静态作用域） var global = 1; function fn1(param1){ var local1 = &#39;local1&#39; var local2 = &#39;local2&#39; function fn2(param2){ var local2 = &#39;inner local2&#39; console."><meta itemprop="datePublished" content="2019-08-30T10:33:22+00:00" />
<meta itemprop="dateModified" content="2019-08-30T10:33:22+00:00" />
<meta itemprop="wordCount" content="235">
<meta itemprop="keywords" content="blog,js,js深入," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="js-函数"/>
<meta name="twitter:description" content="JavaScript 函数 js 中的函数
定义  匿名函数 具名函数 箭头函数  // 匿名函数 var fn = function(){ return 1 } fn2 = fn; fn.name //fn fn2.name //fn // 具名函数 function fn3(){ return 1 } //fn3的作用域是全局 var fn5 = function fn4(){ return 5 } //如果将一个具名函数赋值给一个变量，那么这个具名函数的作用域就是该函数的花括号内 //例如fn4这个具名函数赋值给了fn5 那么fn4存在的作用域就是fn4的花括号内 // 箭头函数 var fn = () =&gt; {} var fn2 = e =&gt; console.log(e) var fn3 = (a, b) =&gt; { let c = a &#43; b; return c; } 词法作用域（也叫静态作用域） var global = 1; function fn1(param1){ var local1 = &#39;local1&#39; var local2 = &#39;local2&#39; function fn2(param2){ var local2 = &#39;inner local2&#39; console."/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold"
      href="https://nanpangyou.github.io/"
      >男胖友de部落格</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#f1efe1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/https://github.com/nanpangyou "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">js-函数</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Aug 30, 2019</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>nanpangyou</span>
      
    </div>
    
  </header>

  <section><h1 id="javascript-函数">JavaScript 函数</h1>
<p>js 中的函数</p>
<h2 id="定义">定义</h2>
<ol>
<li>匿名函数</li>
<li>具名函数</li>
<li>箭头函数</li>
</ol>
<pre tabindex="0"><code>// 匿名函数
var fn = function(){
  return 1
}
fn2 = fn;

fn.name //fn
fn2.name //fn

// 具名函数
function fn3(){
  return 1
}      //fn3的作用域是全局

var fn5 = function fn4(){
  return 5
}
//如果将一个具名函数赋值给一个变量，那么这个具名函数的作用域就是该函数的花括号内
//例如fn4这个具名函数赋值给了fn5 那么fn4存在的作用域就是fn4的花括号内

// 箭头函数
var fn = () =&gt; {}
var fn2 = e =&gt; console.log(e)
var fn3 = (a, b) =&gt; {
  let c = a + b;
  return c;
}
</code></pre><p><img src="%E5%85%B7%E5%90%8D%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="具名函数作用域"></p>
<h2 id="词法作用域也叫静态作用域">词法作用域（也叫静态作用域）</h2>
<pre tabindex="0"><code>var global = 1;
function fn1(param1){
  var local1 = &#39;local1&#39;
  var local2 = &#39;local2&#39;
  function fn2(param2){
    var local2 = &#39;inner local2&#39;
    console.log(local1)
    console.log(local2)
  }
  function fn3(){
    var local2 = &#39;fn3 local2&#39;
    fn2(local2)
  }
}
</code></pre><p><img src="%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg" alt="词法作用域">
词法作用域： 变量的作用域是在定义的时候决定的，而不是执行的时候决定的，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫静态作用域。with 和 eval 除外，所以只能说 JS 的作用域机制非常接近词法作用域（ Lexical scope ）</p>
<p>值得一看的博客<a href="https://js8.in/2011/08/15/javascript%E7%9A%84%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/">javascript 的词法作用域</a></p>
<h2 id="call-stack">call stack</h2>
<p>stack - 栈 - 先进后出</p>
<p><a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYSgpewogICAgY29uc29sZS5sb2coJ2ExJykKICAgIGIoKQogICAgY29uc29sZS5sb2coJ2EyJykKICByZXR1cm4gJ2EnICAKfQpmdW5jdGlvbiBiKCl7CiAgICBjb25zb2xlLmxvZygnYjEnKQogICAgYygpCiAgICBjb25zb2xlLmxvZygnYjInKQogICAgcmV0dXJuICdiJwp9CmZ1bmN0aW9uIGMoKXsKICAgIGNvbnNvbGUubG9nKCdjJykKICAgIHJldHVybiAnYycKfQphKCkKY29uc29sZS5sb2coJ2VuZCcp!!!">简单调用栈</a></p>
<p><a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYSgpewogICAgY29uc29sZS5sb2coJ2ExJykKICAgIGIoKQogICAgY29uc29sZS5sb2coJ2EyJykKICByZXR1cm4gJ2EnICAKfQpmdW5jdGlvbiBiKCl7CiAgICBjb25zb2xlLmxvZygnYjEnKQogICAgYygpCiAgICBjb25zb2xlLmxvZygnYjInKQogICAgcmV0dXJuICdiJwp9CmZ1bmN0aW9uIGMoKXsKICAgIGNvbnNvbGUubG9nKCdjJykKICAgIHJldHVybiAnYycKfQphKCkKY29uc29sZS5sb2coJ2VuZCcp!!!">稍复杂的调用栈</a></p>
<p><a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gZmFiKG4pewogICAgY29uc29sZS5sb2coJ3N0YXJ0IGNhbGMgZmFiICcrIG4pCiAgICBpZihuPj0zKXsKICAgICAgICByZXR1cm4gZmFiKG4tMSkgKyBmYWIobi0yKQogICAgfWVsc2V7CiAgICAgICAgcmV0dXJuIDEKICAgIH0KfQoKZmFiKDUp!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">递归（斐波那契数列）</a></p>
<h2 id="this--argument">this &amp; argument</h2>
<pre tabindex="0"><code>  function f(){
      console.log(this)
      console.log(arguments)
  }
  f.call() // window
  f.call({name:&#39;男胖友&#39;}) // {name: &#39;男胖友&#39;}, []
  f.call({name:&#39;男胖友&#39;},1) // {name: &#39;男胖友&#39;}, [1]
  f.call({name:&#39;男胖友&#39;},1,2) // {name: &#39;男胖友&#39;}, [1,2]
</code></pre><p><strong>注意</strong>
call, apply, bind
call, apply 都是直接调用函数，只有参数上的区别，call 为逗号分割的值，apply 为数组
bind 则返回一个新的函数（并没有调用原来的函数），这个新的函数会 call 原来的函数，call 的参数由你指定</p>
<h2 id="高阶函数柯里化">高阶函数/柯里化</h2>
<ul>
<li>
<p>柯里化:</p>
<p>将 f( x, y )变成 f( 1, y ) 或者 f( x, 1 ) 【固定其余的参数，每次只有一个变量】</p>
</li>
<li>
<p>高阶函数:</p>
<p>至少满足以下条件之一的就可以称为高阶函数</p>
<ol>
<li>接受一个或者多个函数作为输入： forEach, sort, reduce, map 等</li>
<li>输出一个函数： lodash.curry</li>
<li>同时满足以上两个条件： function.prototype.bind</li>
</ol>
</li>
</ul>
<h2 id="回调和构造函数">回调和构造函数</h2>
<ul>
<li>
<p>回调函数
被当做参数的函数就是回调
回调和异步没有关系</p>
</li>
<li>
<p>构造函数
返回对象的函数就是构造函数
一般首字母大写</p>
</li>
</ul>
<h2 id="几个知识">几个知识</h2>
<ol>
<li>对象和对象之间的关系
不同的对象之间，可以通过 <code>__proto__</code> 来互相关联，<code>a.__proto__ = b;c.__proto__ = b;</code> 则  对象 a,c 都共同含有一个共有属性 b。 <code>__proto__</code> 就是共有属性的意思。
通过共有属性，对象和对象之间就可以建立一种联系，减少重复的东西占用的空间</li>
<li>函数和对象之间的关系
关键字<code>this</code>
<code>obj.sayName()</code> 等价于 <code>obj.sayName.call(obj)</code></li>
<li>关键字<code>new</code>
如果你是用 new 和一个构造函数来创建一个对象，那么 new 的作用就是如下图注释掉的三行
<img src="%E4%BD%BF%E7%94%A8new%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.jpg" alt="使用new的构造函数">
<img src="%E4%B8%8D%E4%BD%BF%E7%94%A8new%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.jpg" alt="不使用new的构造函数"></li>
</ol>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://nanpangyou.github.io/tags/blog"
      >blog</a
    >
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://nanpangyou.github.io/tags/js"
      >js</a
    >
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://nanpangyou.github.io/tags/js%E6%B7%B1%E5%85%A5"
      >js深入</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center p-6 pr-3 no-underline"
      href="https://nanpangyou.github.io/post/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-js/"
      ><span class="mr-1.5">←</span><span>代码片段-js</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="https://nanpangyou.github.io/post/node-4/"
      ><span>Node-4</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div id="disqus_thread"></div>
  <script>
    const disqusShortname = '男胖友de部落格';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2022
    <a class="link" href="https://nanpangyou.github.io/">男胖友de部落格</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
