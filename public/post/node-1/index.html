<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #f1efe1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Node-1 - 男胖友de部落格</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="Node - 1 Buffer 缓冲器 什么是 Buffer ?
 它是一个类似于数组的对象，用于存储数据（存储的是二进制数据） Buffer 的效率很高，存储和读取的速度很快，直接对计算机的内存进行操作。 Buffer 的大小一旦确定了，就不可修改 每个元素占用内存的大小为 1 字节 Buffer 是 Node 中非常核心的模块，无需下载和引用就可以直接使用  使用示例
1. Buffer.from() // 将一个字符串存入Buffer中 let str = &#39;hello world&#39; let buf = Buffer.from(str) console.log(buf) 2. Buffer.alloc(); //alloc()方法创建Buffer的效率一般 会开辟一块完全没有使用过的空间 let buf2 = Buffer.alloc(); console.log(buf2) 3. Buffer.allocUnsafe(); //allocUnsafe()方法创建Buffer的效率很好，但是会有一些安全问题 会返回一块没有被引用的空间（有可能会有其他方法不用的数据，数据可能会有安全问题） let buf3 = Buffer.allocUnsafe() console.log(buf3) 4. new Buffer() // 官方不推荐，说是在后续会删除，效率也不高 let buf4 = new Buffer() console.log(buf4) Node 文件系统 Node 中的文件系统：" />
  <meta
    name="author"
    content="nanpangyou"
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://nanpangyou.github.io/main.min.css" />

  

  
     
  <link rel="preload" as="image" href="https://nanpangyou.github.io/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/11482364?v=4" />
  
  

  
  <link rel="preload" as="image" href="https://nanpangyou.github.io/github.svg" />
  

  
  <link rel="icon" href="https://nanpangyou.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://nanpangyou.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.93.3" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="Node-1" />
<meta property="og:description" content="Node - 1 Buffer 缓冲器 什么是 Buffer ?
 它是一个类似于数组的对象，用于存储数据（存储的是二进制数据） Buffer 的效率很高，存储和读取的速度很快，直接对计算机的内存进行操作。 Buffer 的大小一旦确定了，就不可修改 每个元素占用内存的大小为 1 字节 Buffer 是 Node 中非常核心的模块，无需下载和引用就可以直接使用  使用示例
1. Buffer.from() // 将一个字符串存入Buffer中 let str = &#39;hello world&#39; let buf = Buffer.from(str) console.log(buf) 2. Buffer.alloc(); //alloc()方法创建Buffer的效率一般 会开辟一块完全没有使用过的空间 let buf2 = Buffer.alloc(); console.log(buf2) 3. Buffer.allocUnsafe(); //allocUnsafe()方法创建Buffer的效率很好，但是会有一些安全问题 会返回一块没有被引用的空间（有可能会有其他方法不用的数据，数据可能会有安全问题） let buf3 = Buffer.allocUnsafe() console.log(buf3) 4. new Buffer() // 官方不推荐，说是在后续会删除，效率也不高 let buf4 = new Buffer() console.log(buf4) Node 文件系统 Node 中的文件系统：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nanpangyou.github.io/post/node-1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-08-23T15:59:19+00:00" />
<meta property="article:modified_time" content="2019-08-23T15:59:19+00:00" />


  
  <meta itemprop="name" content="Node-1">
<meta itemprop="description" content="Node - 1 Buffer 缓冲器 什么是 Buffer ?
 它是一个类似于数组的对象，用于存储数据（存储的是二进制数据） Buffer 的效率很高，存储和读取的速度很快，直接对计算机的内存进行操作。 Buffer 的大小一旦确定了，就不可修改 每个元素占用内存的大小为 1 字节 Buffer 是 Node 中非常核心的模块，无需下载和引用就可以直接使用  使用示例
1. Buffer.from() // 将一个字符串存入Buffer中 let str = &#39;hello world&#39; let buf = Buffer.from(str) console.log(buf) 2. Buffer.alloc(); //alloc()方法创建Buffer的效率一般 会开辟一块完全没有使用过的空间 let buf2 = Buffer.alloc(); console.log(buf2) 3. Buffer.allocUnsafe(); //allocUnsafe()方法创建Buffer的效率很好，但是会有一些安全问题 会返回一块没有被引用的空间（有可能会有其他方法不用的数据，数据可能会有安全问题） let buf3 = Buffer.allocUnsafe() console.log(buf3) 4. new Buffer() // 官方不推荐，说是在后续会删除，效率也不高 let buf4 = new Buffer() console.log(buf4) Node 文件系统 Node 中的文件系统："><meta itemprop="datePublished" content="2019-08-23T15:59:19+00:00" />
<meta itemprop="dateModified" content="2019-08-23T15:59:19+00:00" />
<meta itemprop="wordCount" content="307">
<meta itemprop="keywords" content="note,node," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Node-1"/>
<meta name="twitter:description" content="Node - 1 Buffer 缓冲器 什么是 Buffer ?
 它是一个类似于数组的对象，用于存储数据（存储的是二进制数据） Buffer 的效率很高，存储和读取的速度很快，直接对计算机的内存进行操作。 Buffer 的大小一旦确定了，就不可修改 每个元素占用内存的大小为 1 字节 Buffer 是 Node 中非常核心的模块，无需下载和引用就可以直接使用  使用示例
1. Buffer.from() // 将一个字符串存入Buffer中 let str = &#39;hello world&#39; let buf = Buffer.from(str) console.log(buf) 2. Buffer.alloc(); //alloc()方法创建Buffer的效率一般 会开辟一块完全没有使用过的空间 let buf2 = Buffer.alloc(); console.log(buf2) 3. Buffer.allocUnsafe(); //allocUnsafe()方法创建Buffer的效率很好，但是会有一些安全问题 会返回一块没有被引用的空间（有可能会有其他方法不用的数据，数据可能会有安全问题） let buf3 = Buffer.allocUnsafe() console.log(buf3) 4. new Buffer() // 官方不推荐，说是在后续会删除，效率也不高 let buf4 = new Buffer() console.log(buf4) Node 文件系统 Node 中的文件系统："/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold"
      href="https://nanpangyou.github.io/"
      >男胖友de部落格</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#f1efe1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/https://github.com/nanpangyou "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">Node-1</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Aug 23, 2019</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>nanpangyou</span>
      
    </div>
    
  </header>

  <section><h1 id="node---1">Node - 1</h1>
<h2 id="buffer-缓冲器">Buffer 缓冲器</h2>
<p>什么是 Buffer ?</p>
<ol>
<li>它是一个类似于数组的对象，用于存储数据（存储的是二进制数据）</li>
<li>Buffer 的效率很高，存储和读取的速度很快，直接对计算机的内存进行操作。</li>
<li>Buffer 的大小一旦确定了，就不可修改</li>
<li>每个元素占用内存的大小为 1 字节</li>
<li>Buffer 是 Node 中非常核心的模块，无需下载和引用就可以直接使用</li>
</ol>
<p>使用示例</p>
<pre tabindex="0"><code>1. Buffer.from()
  // 将一个字符串存入Buffer中
    let str = &#39;hello world&#39;
    let buf = Buffer.from(str)
    console.log(buf)

2. Buffer.alloc();
  //alloc()方法创建Buffer的效率一般 会开辟一块完全没有使用过的空间
    let buf2 = Buffer.alloc();
    console.log(buf2)

3. Buffer.allocUnsafe();
  //allocUnsafe()方法创建Buffer的效率很好，但是会有一些安全问题 会返回一块没有被引用的空间（有可能会有其他方法不用的数据，数据可能会有安全问题）
    let buf3 = Buffer.allocUnsafe()
    console.log(buf3)

4. new Buffer()
  // 官方不推荐，说是在后续会删除，效率也不高
    let buf4 = new Buffer()
    console.log(buf4)
</code></pre><h2 id="node-文件系统">Node 文件系统</h2>
<p>Node 中的文件系统：</p>
<ol>
<li>在 Node 中有一个文件系统，所谓文件系统，就是对计算机中的文件进行增删查改等操作</li>
<li>在 Node 中，提供了一个模块，叫 fs 模块，专门由于用户操作文件</li>
<li>fs 模块，是 Node 的核心模块，使用的时候，要引入，无需下载</li>
</ol>
<pre tabindex="0"><code>let fs = require(&#39;fs&#39;)
</code></pre><h3 id="简单文件写入">简单文件写入</h3>
<p>语法：<code>fs.writeFile(file, data[,options], callback)</code></p>
<p>参数：
&ndash;file ： 文件名+文件路径
&ndash;data ：要写入的数据
&ndash;options ： 配置选项</p>
<blockquote>
<p>&ndash;flag : 打开文件要进行的操作 &lsquo;w&rsquo;:写入(默认) &lsquo;a&rsquo;:追加
&ndash;mode : 文件权限的限制 （默认是 0o666: 文件可读可写 0o222+0o444） 0o111:文件可被执行 0o222:文件可被读取 0o444:文件可被写入
&ndash;encoding : utf8(默认值)</p>
</blockquote>
<p>&ndash;callback ： 回调函数</p>
<pre tabindex="0"><code>const fs = require(&#39;fs&#39;)
fs.writeFile(&#39;./test.md&#39;,&#39;test content&#39;,(err)=&gt;{
  if(!err){
    console.log(&#39;success&#39;);
  }else{
    console.log(err);
  }
})
</code></pre><h4 id="简单文件写入的不足">简单文件写入的不足</h4>
<p>简单文件写入是一次性将所有要写入的数据加载到内存中，对于比较大的数据容易造成内存溢出。适用于较小的文件写入。</p>
<h3 id="流式文件写入">流式文件写入</h3>
<p>流，分为 可读流，可写流</p>
<ol>
<li>创建一个可写流</li>
</ol>
<p><code>fs.createWriteStream(path[, options])</code>
&ndash;path: 文件路径+文件名
&ndash;options: 配置对象（可选）</p>
<blockquote>
<p>flags : 打开文件要进行的操作 &lsquo;w&rsquo;:写入(默认) &lsquo;a&rsquo;:追加
mode : 文件权限的限制 （默认是 0o666: 文件可读可写 0o222+0o444） 0o111:文件可被执行 0o222:文件可被读取 0o444:文件可被写入
encoding : utf8（默认）
fd : 文件的唯一标识
autoClose : 当数据操作完毕后，自动关闭文件，默认值是 true
start : 文件写入的其实位置 文件中的位置，不是内存中的位置</p>
</blockquote>
<pre tabindex="0"><code>const fs = require(&#39;fs&#39;)
let ws = fs.createWriteStream(&#39;./demo.md&#39;)
// 只要使用了流，需要给流加监听，来控制打开和关闭。
ws.on(&#34;open&#34;,()=&gt;{
  console.log(&#39;流打开了&#39;)
})
ws.on(&#34;close&#34;,()=&gt;{
  console.log(&#34;流关闭了&#34;)
})

ws.write(&#39;马上上学了，\n&#39;)
ws.write(&#39;饿了，\n&#39;)
ws.write(&#39;忍着  \n&#39;)
// ws.close()  //如果用的是8版本以下（包括8版本），用close方法关闭流，会造成数据的丢失，这个时候推荐使用end方法
ws.end()
</code></pre><h3 id="简单文件读取">简单文件读取</h3>
<p><code>fs.readFile(path[, options], callback)</code></p>
<p>&ndash;path: 文件路径和文件名字
&ndash;options： 配置对象</p>
<blockquote>
<p>flag: &lsquo;a&rsquo; add 加入 ， &lsquo;w&rsquo; write 写入 , &lsquo;r&rsquo; read 读取
encoding: utf8 （默认）</p>
</blockquote>
<p>&ndash;callback: 回调函数</p>
<blockquote>
<p>err: 错误对象
data ： 数据</p>
</blockquote>
<pre tabindex="0"><code>const fs = require(&#39;fs&#39;)
fs.readFile(&#39;./demo.md&#39;,(err,data)=&gt;{
  if(!err){
    console.log(data)
    //打印的是buffer类型的数据，如果本身文件是文本，可以调用Buffer自身的toString()方法，将buffer类型的数据转换成文本
    //如果本身文件为非文本（例如：mp3 mp4 rar等其他类型），Buffer格式的数据较为方便操作
  }else{
    console.log(err)
  }
})
</code></pre><h3 id="流式文件读取">流式文件读取</h3>
<p><code>fs.createReadStream(path[, options])</code></p>
<p>&ndash;path: 文件路径 + 文件名
&ndash;options: 配置文件</p>
<blockquote>
<p>start : 读取的起始点
end : 读取的结束点
highWaterMark ：每次读取的数据大小 默认值是 64* 1024 （65536） kb</p>
</blockquote>
<pre tabindex="0"><code>const fs = require(&#39;fs&#39;)
// 创建一个可读流

let rs = fs.createReadStream(&#39;./demo.md&#39;)
let ws = fs.createWriteStream(&#39;./demo-out.md&#39;)

//  监听读取流
rs.on(&#39;open&#39;,()=&gt;{
  console.log(&#39;开始读取&#39;)
})
rs.on(&#39;close&#39;,()=&gt;{
  console.log(&#39;读取结束&#39;)
  ws.end()
})
//  监听写入流
ws.on(&#39;open&#39;,()=&gt;{
  console.log(&#39;写入开始&#39;)
})
ws.on(&#39;close&#39;,()=&gt;{
  console.log(&#39;读取结束&#39;)
})

// 当给可读流绑定一个data事件，会自动触发流读取文件
rs.on(&#39;data&#39;,data=&gt;{
  console.log(data)   // 读取的数据
  console.log(data.toString())  // 读取的Buffer字符串化
  console.log(data.length)  // 读取的Buffer长度
  ws.write(data)

})
</code></pre></section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://nanpangyou.github.io/tags/note"
      >note</a
    >
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://nanpangyou.github.io/tags/node"
      >node</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center p-6 pr-3 no-underline"
      href="https://nanpangyou.github.io/post/node-2/"
      ><span class="mr-1.5">←</span><span>Node-2</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end p-6 pl-3 no-underline"
      href="https://nanpangyou.github.io/post/node-0/"
      ><span>Node-0</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div id="disqus_thread"></div>
  <script>
    const disqusShortname = '男胖友de部落格';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2022
    <a class="link" href="https://nanpangyou.github.io/">男胖友de部落格</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
